<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript中的this]]></title>
    <url>%2F2019%2F08%2F01%2FJavaScript%20%E4%B8%AD%E7%9A%84%20this%2F</url>
    <content type="text"><![CDATA[what’s this ？最近稍稍有点空闲，复习一下基础知识。说起 JavaScript 这门语言让人头疼的地方， 就绕不开 this 关键字的指向问题。 经过孜孜不倦地翻阅各大 IT 牛人的博客和相关网站之后……被虐的过程就不详细描述了！！ 总之，学习完之后，我就 “人不住手” 地总结了一下学到的知识，分享给大家。 学习 this 的必要众所周知，JavaScript 是一门基于原型的编程语言，我们可以通过使用关键词new 和 this 来实现代码的复用。 通过学习 this 等相关知识，能帮助你更好了解这门语言的设计模式和特性，加深你对代码的理解与使用。 this 是什么？this 指向谁？ this 是 JS 关键字，代表了一个空间地址。 this 是一个指针，指向函数运行时所在的环境。 通俗讲，就是谁调用了函数，函数内的 this 就指向谁。因此，我们想知道 this 指向谁，就一定要清楚到底是谁调用了函数。（PS：哈哈哈，说了句废话。） this 的四种调用默认调用 独立函数调用时，this 指向 window 对象 123456789// 注意:这里不能使用letvar a = 1 // 全局用let声明的变量不属于windowfunction fn()&#123; console.log(this.a)&#125;// fn函数当前运行环境是 &quot;window&quot; 对象，所以this指向 全局window对象fn() // 1 严格模式下，默认绑定的 this 指向 undefined 。 1234;(function() &#123; &apos;use strict&apos; console.log(this) // undefined&#125;)() 对象调用 如果函数执行时有上下文对象，会把函数里的 this 默认绑定到这个上下文对象上。 12345678910111213141516171819var a = 10function fn()&#123; console.log(this.a);&#125;let obj = &#123; a : 20, fn : fn&#125;// 对象obj调用了fn函数，fn的this指向当前的运行环境 &quot;obj&quot; 对象，输出20obj.fn() // 20// 因为 obj.fn 是引用类型，即 objFn === fn函数。let objFn = obj.fn// 独立调用函数 objFn，fn的this指向当前的运行环境 &quot;window&quot; 对象，输出10objFn() // 10 多层调用时，默认获取最后一层调用的上下文对象。 123456789101112131415161718var a = 10function fn() &#123; console.log(this.a)&#125;let obj = &#123; a: 20, fn: fn&#125;let obj2 = &#123; a: 30, obj: obj&#125;// 默认绑定最后调用的上下文，即this 指向 obj。obj2.obj.fn() // 20 call、apply、bind 强制绑定 通过 call、apply、bind 改变函数的 this 指向。 绑定后无论怎么调用，也不会改变其 this 指向。 12345678910111213141516let obj = &#123; a: 10&#125;let obj2 = &#123; a: 20, fn() &#123; console.log(this.a) &#125;&#125;function fn2() &#123; obj2.fn.call(obj) // 把obj2.fn的this指向对象obj&#125;// 虽然执行环境是 &quot;window&quot;，但是因为通过call强制绑定了this，所以输出10fn2() // 10 new 绑定调用老生常谈，先看看 JS 中 new 关键字做了什么： 在内存中创建一个新对象 将新对象的proto指向构造函数的原型 prototype 对象 将构造函数的作用域赋值给新对象，（this 指向新对象） 执行构造函数中的代码（给这个新对象加属性和方法） 返回新对象，如果这个函数没有返回其他对象。 得出结论： 使用 new 调用函数，返回的对象的 this 始终指向自身。 12345678910111213141516function fn() &#123; this.a = 10 console.log(this)&#125;// obj 是从new出来的实例var obj = new fn() // fn &#123;a: 10&#125;// obj的this指向自身console.log(obj.a) // 10console.log(window.a) // undefined// &quot;window&quot;环境下执行了fn函数，this指向fnfn() // window对象console.log(window.a) // 10 箭头函数的 this箭头函数区别于以上介绍的运行规则，而是完全根据外部作用域来决定 this，但其父级是遵循 this 绑定规则的（即：如果箭头函数的父级的 this 指向 window，那么箭头函数的 this 也指向 window） 通过例子认识下： 1234567let obj=&#123; a:10, fn:function()&#123; setTimeout(function()&#123;console.log(this.a)&#125;) &#125;&#125;;obj.fn() // undefined 上述例子，可以发现在 setTimeout 中传入函数时，函数中的 this 会指向 window 对象，那么怎样让 this 指向 obj 对象? 修改下代码： 1234567let obj=&#123; a:10, fn:function()&#123; setTimeout(()=&gt;&#123;console.log(this.a)&#125;); &#125;&#125;;obj.fn() // 10 发现在我们使用箭头函数之后，使其继承了父函数 obj.fn 的 this 指针，达到了如下相同效果： 1234567let obj = &#123; a: 10, fn: function() &#123; console.log(this.a) &#125;&#125;obj.fn() // 10 看到这里，应该以及理解了箭头函数的 this 是继承来的意思。让我们再通过几个例子方便去理解箭头函数中的 this。 例 1： 12345678910let obj = &#123; fn: () =&gt; &#123; console.log(this) &#125;, fn2() &#123; console.log(this) &#125;&#125;obj.fn() // window对象obj.fn2() // &#123;fn: ƒ, fn2: ƒ&#125; 相信你一定很疑惑，为什么上述箭头函数里输出的是 window 对象，那么再看一段代码就清楚了。 例 2： 1234let obj = &#123; that: this&#125;console.log(obj.that) // window对象 我们发现，obj 里的 this 指向的是全局的 window 对象，那么就很好理解了，箭头函数继承了 obj 中的 this，也指向了全局 window 对象。 最后，我们可以通过箭头函数实现强制绑定 this 的效果。 没修改前的代码： 1234567891011121314var a = 10let obj = &#123; a : 20, fn() &#123; console.log(this.a); &#125;&#125;obj.fn() // 20let objFn = obj.fnobjFn() // 10 以上例子是我们讲解对象调用时的例子，我们不难发现，直接用 obj 对象去调用和独立调用时输出的结果不一致。如果你有仔细阅读文章的话，应该不难理解造成这种情形的原因。 接下来，我们通过箭头函数改造下代码，使我们复制的引用，独立调用时 this 也指向 obj。 修改后的代码： 12345678910111213141516171819var a = 10let obj = &#123; a: 20, fn() &#123; return () =&gt; &#123; console.log(this.a) &#125; &#125;&#125;obj.fn()() // 20let objFn = obj.fn()objFn() // 20// 发现即使是用call强制绑定，也无法改变其thisobjFn.call(window) // 20 END知之，行知，方得芝。 转载分享，请标明出处。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识ES6中的Symbol]]></title>
    <url>%2F2019%2F07%2F16%2F%E5%88%9D%E8%AF%86ES6%E4%B8%AD%E7%9A%84Symbol%2F</url>
    <content type="text"><![CDATA[Symbol文章内容参考《ECMAScript 6 入门》。 概述Symbol 是 ES6 引入的一种新的原始数据类型，是独一无二的值。 注意： Symbol 函数不能使用 new 命令，因为生成的 Symbol 是一个原始类型的值，不是对象。 JavaScript 的七种数据类型： Undefined Null Boolean String Number Object Symbol 判断数据类型的方法123let data = Symbol()Object.prototype.toString.call(data).slice(8,-1) // &quot;Symbol&quot; 使用事项 Symbol 是独一无二的值。 1234567let idx = Symbol(&apos;pro&apos;)let key = Symbol(&apos;pro&apos;)idx // Symbol(pro)key // Symbol(pro)a === b // false Symbol 函数可以接受一个字符串作为参数（如：例 1），表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。 123456// 无法区分两者let s1 = Symbol()let s2 = Symbol()s1 // Symbol()s2 // Symbol() 当 Symbol 的参数是一个对象，就会调用该对象的 toString 方法（执行拆箱操作），将其转为字符串，然后才生成一个 Symbol 值。 1234567const obj = &#123; toString() &#123; return &apos;abc&apos; &#125;&#125;;const sym = Symbol(obj)sym // Symbol(abc) Symbol 值可以显式转为字符串和布尔值。但是不能转换成数值，也不能与其他类型的值进行运算，会报错。 转字符串 1234567let s = Symbol(&apos;Str Symbol&apos;)String(s) // &apos;Symbol(Str Symbol)&apos;s.toString() // &apos;Symbol(Str Symbol)&apos;// 不能将Symbol强制转换为字符串或是数字类型s + &apos;&apos; // TypeError: Cannot convert a Symbol value to a string 转布尔 123let s = Symbol(&apos;Str Symbol&apos;)Boolean(s) // true 转数值，运算 12345let s = Symbol(&apos;Str Symbol&apos;)Number(s) // Cannot convert a Symbol value to a number&apos;look at this&apos; + s // TypeError: Cannot convert a Symbol value to a string Symbol 函数不能使用 new 命令，因为生成的 Symbol 是一个原始类型的值，不是对象。 1new Symbol() // TypeError: Symbol is not a constructor Symbol.prototype.description创建 Symbol 的时候，可以添加一个描述。 1const s = Symbol(&apos;sym&apos;) 上面代码中，s 的描述就是字符串 sym。 但是，读取这个描述需要将 Symbol 显式转为字符串，即下面的写法。 123const s = Symbol(&apos;sym&apos;)String(s).slice(7,-1) // &quot;sym&quot; 上面的用法不是很方便。ES2019 提供了一个实例属性 description，直接返回 Symbol 的描述。 123const s = Symbol(&apos;sym&apos;)s.description // &quot;sym&quot; Symbol 作为对象属性名根据每一个 Symbol 值都是不等的特性，可以用 Symbol 作为唯一标识符，使用 Symbol 作为对象属性名可以保证不会出现同名的属性。 注意： symbol 不是字符串类型！！！使用 symbol 作为对象属性名时，必须放在方括号 [ ]之 中,因为点运算符后面总是字符串。 1234567891011121314151617let mySymbol = Symbol();// 第一种写法let a = &#123;&#125;;a[mySymbol] = &apos;Hello!&apos;;// 第二种写法let a = &#123; [mySymbol]: &apos;Hello!&apos;&#125;;// 第三种写法let a = &#123;&#125;;Object.defineProperty(a, mySymbol, &#123; value: &apos;Hello!&apos; &#125;);// 以上写法都得到同样结果a[mySymbol] // &quot;Hello!&quot; 使用 Symbol 来代替常量我们经常需要用一组常量区分不同的类型，处理不同的逻辑。其实我们并不在意这几个常量值是什么，只要是唯一的。这时可以用 Symbol 来实现。 123456789101112131415161718192021const apple = &apos;myApple&apos;const orange = &apos;myOrange&apos;const pear = &apos;myPear&apos;function getFruit(fruit) &#123; switch (fruit) &#123; case apple: console.log(&apos;我是a先生&apos;) break case orange: console.log(&apos;我是b女士&apos;) break case pear: console.log(&apos;我是c女士&apos;) break default: console.log(&apos;这是什么&apos;) &#125;&#125;getFruit(apple) // 我是a先生 观察以上代码，我们会发现，上述定义的常量值是什么并不重要。只要保证常量值间互不相等即可。 直接使用 Symbol 赋值即可： 123const apple = Symbol()const orange = Symbol()const pear = Symbol() Symbol 属性检索以 Symbol 作为属性名，不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。 Object.getOwnPropertySymbols 方法：获取指定对象的所有 Symbol 属性名的集合数组 123456789const a = Symbol(&apos;a&apos;)const b = Symbol(&apos;b&apos;)let obj = &#123; [a]: &apos;aaa&apos;, [b]: &apos;bbb&apos;&#125;console.log(Object.getOwnPropertySymbols(obj)) // [ Symbol(a), Symbol(b) ] Reflect.ownKeys 方法：返回所有类型的键名，包括常规键名和 Symbol 键名。 1234567let obj = &#123; [Symbol(&apos;a&apos;)]: &apos;aaa&apos;, b: &apos;bbb&apos;, c: &apos;ccc&apos;&#125;console.log(Reflect.ownKeys(obj)) // [ &apos;b&apos;, &apos;c&apos;, Symbol(a) ]st Symbol 定义类的私有属性/方法 (重点)以 Symbol 值作为名称的属性，不会被常规方法遍历得到。利用这个特性，可以为对象定义一些非私有的、但又希望只用于内部的方法。 123456789101112131415function myObject(name, age) &#123; let Age = Symbol() this.name = name this[Age] = age this.checkAge = (num) =&gt; &#123; return this[Age] === num &#125;&#125;let func = new myObject(&apos;z先生&apos;, 18)console.log(func.checkAge(18)) // trueconsole.log(func.name) // z先生console.log(func.age) // undefinedconsole.log(func[age]) // age is not defined Symbol 共享体系如果想创建一个可共享的 Symbol，可以使用 Symbol.for()方法。 Symbol.for 方法，接收一个字符串参数，然后全局环境中搜索有没有以该字符串参数作为名称的 Symbol 值： 如果有，就返回这个 Symbol 值 否则就全局环境中登记新建并返回一个以该字符串为名称的 Symbol 值。 123456789let s1 = Symbol.for(&apos;s&apos;)let s2 = Symbol(&apos;s&apos;)let s3 = Symbol.for(&apos;s&apos;)s1 === s2 // falses1 === s3 // trueSymbol(&apos;sym&apos;) === Symbol(&apos;sym&apos;) // falseSymbol.for(&apos;sym&apos;) === Symbol.for(&apos;sym&apos;) // true 注意： Symbol.for 为 Symbol 值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker 中取到同一个值。 12345iframe = document.createElement(&apos;iframe&apos;);iframe.src = String(window.location);document.body.appendChild(iframe);iframe.contentWindow.Symbol.for(&apos;foo&apos;) === Symbol.for(&apos;foo&apos;) // true 上面代码中，iframe 窗口生成的 Symbol 值，可以在主页面得到。 END知之，行知，方得芝。 转载分享，请标明出处。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB常用语法]]></title>
    <url>%2F2019%2F04%2F28%2FMongoDB%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.基本指令 db ———— 查看当前正在使用的数据库 db.stats() ———— 查看当前数据库状态 show dbs ———— 显示所有数据库 如果数据为空，不会显示 use &lt;数据库名&gt; ———— 进入指定数据库 show collections ———— 显示当前数据库的集合 db.&lt;集合名&gt;.drop() ———— 删除指定集合 db.dropDatabase() ———— 删除当前数据库 2.MongoDB 的增删改查1234567$gte：大于等于$lte：小于等于$gt：大于$lt：小于 2.1 查看语法：db.&lt;集合名&gt;.find({}) 例子： 1234567// 指定条件查询：// 查询letao集合里name值为jack的数据db.collection.find(&#123;name: &apos;jack&apos;&#125;)// 查询letao集合里age值大于18的数据db.collection.find(&#123;age:&#123;$gt:18&#125;&#125;) 2.1.1 查询数据数量12// 后面加上 .count()db.collection.find(&#123;&#125;).count(); 2.1.2 数据排序12// col 集合中的数据按字段 likes 的降序排列 (1是正序，-1是倒序)db.collection.find(&#123;&#125;).sort(&#123;&quot;likes&quot;:-1&#125;) 2.1.3 模糊查询1234567891011121314// sql语法:select * from user where name like &quot;%花%&quot;;// MongoDB语法:db.collection.find(&#123;name:/花/&#125;);// 例子：查看students里的name包含 ”测试“ 的数据。db.collection.find(&#123;students.name:/测试/&#125;)// 若是以测试为开头的：db.collection.find(&#123;students.name:/^测试/&#125;)// 若是以测试为结尾的：db.collection.find(&#123;students.name:/测试$/&#125;) 2.1.4 查询表里 存在 指定字段(即值不为 null) 的数据12// 查询有age属性的数据（true是有，false没有）db.collection.find(&#123;age:&#123;$exists:true&#125;&#125;) 2.1.5 查询多个条件 返回符合其中一项 的数据12// 查找name值为zs 或 ls的数据db.collection.find(&#123;$or:[&#123;name:&apos;zs&apos;&#125;,&#123;name:&apos;ls&apos;&#125;]&#125;) 2.1.6 and 和 or 联合使用12// 查询age值为18，name值为张三或者李四的数据（注意是一个对象）db.collection.find(&#123; age:18 , $or: [ &#123;name:&apos;张三&apos;&#125;,&#123;name:&apos;李四&apos;&#125; ] &#125;) 2.1.7 查询 返回指定数量的数据指定数量：limit(数量) 跳过行数：skip(跳过数量) 12345// 找到的数据返回前5条db.collection.find().limit(5)// 找到的数据返回 跳过3条后的2条（即第4、5条）db.collection.find().limit(2).skip(3) 2.1.8 查询一个字段 多个条件 返回 符合其中之一的数据123&lt;!--需求：letao集合里age为 3 或 5 或 8 的数据--&gt;db.collection.find(&#123;age:&#123;$in:[3,5,8]&#125;&#125;)&lt;!--这里使用的是$in--&gt; 2.1.9 查询指定字段 指定类型的数据12345// 查询name类型为double类型的数据db.collection.find( &#123;name: &#123;$type:&apos;double&apos;&#125; &#125; )// 查询name类型为string类型的数据db.collection.find( &#123;name: &#123;$type:&apos;string&apos;&#125; &#125; ) 2.1.10 数组查询1234&lt;!--实例，一节课的老师的id可能有多个，这样：--&gt;&lt;!--&quot;teachers&quot; : [ 391, 659, 1534 ]--&gt;&lt;!--需求：查询包含老师id为1534的所有的数据--&gt;db.collection.find(&#123;teachers:1534&#125;) 2.1.11 查询数据 返回时 显示指定字段1234&lt;!--classes表集合中只显示id和title两个字段--&gt;&lt;!--下面的 status:&quot;700&quot; 为查询条件--&gt;&lt;!--查询出classes即合理status值为700的数据，只显示id和title--&gt;db.collection.find(&#123;status:&quot;700&quot;&#125;,&#123;_id:1,title:1&#125;) 2.2 插入语法：db.&lt;集合名&gt;.insert({}) 例子： 12345// 插入一条db.users.insert(&#123;name: &apos;jack&apos;, age: 18, gender: &apos;male&apos;&#125;)// 插入多条db.users.insertMany( [ &#123;name: &apos;tom&apos;, age: 19&#125;, &#123;name: &apos;jerry&apos;, age: 20&#125; ] ) 2.3 修改语法：db.&lt;集合名&gt;.update({}) 例子： 12345// 修改一条 name属性值为jack的数据，将其age改为20db.users.updateOne(&#123;name: &apos;jack&apos;&#125;, &#123;$set: &#123;age: 20&#125;&#125;)// 修改所有 age大于19的数据，将name设置为 中年人db.users.updateMany(&#123;age: &#123;$gt: 19&#125;&#125;,&#123;$set: &#123;name: &apos;中年人&apos;&#125;&#125;) 2.3.1 删除数据指定字段（不是删数据行） $exists：为 true 代表有这个字段名存在的项$unset: 替换成 null，\$unset 替换指定的元素为 null 而不是删除掉指定的元素，此行为保持数组大小和位置一致 123456789101112131415161718192021&lt;!--参数multi设置为true表示对集合中的所有匹配项执行该命令，若设置为false则只修改找到的第一条文档。--&gt;&lt;!--寻找到letao集合中有age这个属性的所有项，修改它们的name值为null --&gt;&lt;!--注意： 不管你值设为啥，$unset都把你选择字段删除--&gt;db.letao.update(&#123;&apos;age&apos;:&#123;$exists:true&#125;&#125;, &#123;$unset:&#123;name:&apos;zs&apos;&#125;&#125;, &#123;multi:true&#125;)db.letao.update(&#123;&apos;age&apos;:&#123;$exists:true&#125;&#125;, &#123;$unset:&#123;name:&apos;&apos;&#125;&#125;, false,true) // 第一个Boolean代表如果没有找到数据，是否插入一条第二个Boolean代表是否匹配所有找到数据&lt;!--如果指定的字段不存在则操作不做任何处理；--&gt;&lt;!--当使用$操作符匹配任何数组元素，$unset替换指定的元素为null而不是删除掉指定的元素，此行为保持数组大小和位置一致；--&gt;&lt;!--如下update()操作删除掉符合条件sku为unknown的文档字段quantity和instock--&gt;db.products.update( &#123; sku: &quot;unknown&quot; &#125;, &#123; $unset: &#123; quantity: &quot;&quot;, instock: &quot;&quot; &#125; &#125;) 2.4 删除语法：db.&lt;集合名&gt;.delete({}) 例子： 12345// 删除一条 age 为18的数据：db.users.deleteOne(&#123;age: 18&#125;)// 删除所有name为jack的数据db.users.deleteMany(&#123; name: &apos;jack&apos; &#125;) 3.设置使用索引（重要）作用：给字段设置索引可以加快查询此字段的速度 语法： 设置值为 1 就代表按照升序进行索引，-1 代表按照降序进行索引。 查看索引状态：db.表名.getIndexed()设置索引：db.表名.createIndex()删除索引：db.表名.dropIndex() 1234567891011// 查看当前letao表所有索引的状态db.letao.getIndexes()// 给title字段设置升序的索引，因为设置了unique为true，表示title值不能重复db.letao.createIndex(&#123;title:1&#125;,&#123;unique:true&#125;)// 设置title字段为升序，age字段为降序的组合索引db.letao.createIndex(&#123;title:1&#125;,&#123;age:-1&#125;)// 删除title字段为升序的索引db.letao.dropIndex(&#123;title:1&#125;) END…]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mui组件通用css类]]></title>
    <url>%2F2019%2F01%2F23%2Fmui%E7%BB%84%E4%BB%B6%E9%80%9A%E7%94%A8css%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[mui 通用类最近要用 mui 框架写一个项目。 于是根据官网资料和查阅资料整理了一下 mui 常用的 css 类。 注意： 一切内容都要包裹在 .mui-content 中，否则就有可能被固定栏遮罩，除了固定栏之外。 固定栏是指带有 .mui-bar 属性的节点，他们都是基于 fixed 定位的，使用时需遵循一个规则：放在.mui-content 元素之前。 即使是底部工具条和底部选项卡，也要放在 .mui-content 之前，否则固定栏会遮住部分主内容。 颜色（color） danger 红色(red) warning 黄色(yellow) primary 蓝色(blue) success 绿色(green) royal 紫色(purple) 注意：.mui-btn-primary 等效于.mui-btn-blue; 背景颜色可以给任意元素添加 .mui-bg-*类添加背景颜色，可选参数为 primary/positive/negative。 123&lt;div class=&quot;mui-bg-negative&quot;&gt;红色背景&lt;/div&gt;&lt;div class=&quot;mui-bg-primary&quot;&gt;蓝色背景&lt;/div&gt;&lt;div class=&quot;mui-bg-positive&quot;&gt;绿色背景&lt;/div&gt; 示例图： badge（数字角标）角标的核心类是 .mui-badge，默认为实心灰色背景；同时，mui 还内置了蓝色（blue）、绿色(green)、黄色(yellow)、红色(red)、紫色(purple)五种色系的数字角标，如下： 123456&lt;span class=&quot;mui-badge&quot;&gt;默认灰色&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-primary&quot;&gt;蓝色&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-success&quot;&gt;绿色&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-warning&quot;&gt;黄色&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-danger&quot;&gt;红色&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-purple&quot;&gt;紫色&lt;/span&gt; 示例图：如果不要底色，则增加 .mui-badge-inverted 类即可，如下： 123456&lt;span class=&quot;mui-badge mui-badge-inverted&quot;&gt;默认灰色&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-primary mui-badge-inverted&quot;&gt;蓝色&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-success mui-badge-inverted&quot;&gt;绿色&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-warning mui-badge-inverted&quot;&gt;黄色&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-danger mui-badge-inverted&quot;&gt;红色&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-purple mui-badge-inverted&quot;&gt;紫色&lt;/span&gt; 示例图： 按钮在 button 节点上增加.mui-btn 类，即可生成默认按钮；若需要其他颜色的按钮，则继续增加对应 class 即可。默认按钮有底色，运行效果如下： 123456&lt;button type=&quot;button&quot; class=&quot;mui-btn&quot;&gt;默认&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-primary&quot;&gt;蓝色&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-success&quot;&gt;绿色&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-warning&quot;&gt;黄色&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-danger&quot;&gt;红色&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-royal&quot;&gt;紫色&lt;/button&gt; 示例图： 若希望无底色、有边框的按钮，仅需增加 .mui-btn-outlined 类即可，代码如下： 123456&lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-outlined&quot;&gt;默认&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-primary mui-btn-outlined&quot;&gt;蓝色&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-success mui-btn-outlined&quot;&gt;绿色&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-warning mui-btn-outlined&quot;&gt;黄色&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-danger mui-btn-outlined&quot;&gt;红色&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-royal mui-btn-outlined&quot;&gt;紫色&lt;/button&gt; 示例图： 字体样式文字对齐通过 .mui-text-*来控制文字对齐方式,代码如下： 123&lt;div class=&quot;mui-text-left mui-bg-negative&quot;&gt;居左&lt;/div&gt;&lt;div class=&quot;mui-text-center mui-bg-primary&quot;&gt;居中&lt;/div&gt;&lt;div class=&quot;mui-text-right mui-bg-positive&quot;&gt;居右&lt;/div&gt; 示例图： 文字溢出省略.mui-ellipsis 来控制文字溢出省略需要设置显示多行，通过设置-webkit-line-clamp 属性，如显示三行添加 style=”-webkit-line-clamp:3”，代码如下： 123456789&lt;p class=&quot;mui-ellipsis&quot;&gt;超出一行的文字省略，超出一行的文字省略，超出一行的文字省略，超出一行的文字省略&lt;/p&gt;&lt;br/&gt;&lt;p class=&quot;mui-ellipsis-2&quot;&gt;超出两行的文字省略，超出两行的文字省略，超出两行的文字省略，超出两行的文字省略，超出两行的文字省略，超出两行的文字省略&lt;/p&gt;&lt;br/&gt;&lt;p class=&quot;mui-ellipsis-2&quot; style=&quot;-webkit-line-clamp:3&quot;&gt;超出三行的文字省略，超出三行的文字省略，超出三行的文字省略，超出三行的文字省略，超出三行的文字省略，超出三行的文字省略，超出三行的文字省略，超出三行的文字省略超出三行的文字省略，&lt;/p&gt; 示例图： 浮动给元素设置.mui-pull-left 或者.mui-pull-right 类，设置浮动。使用.mui-clearfix 清除浮动。 1234&lt;div class=&quot;mui-clearfix&quot;&gt; &lt;div class=&quot;mui-pull-left mui-bg-negative&quot;&gt;我在左边&lt;/div&gt; &lt;div class=&quot;mui-pull-right mui-bg-primary&quot;&gt;我在右边&lt;/div&gt;&lt;/div&gt; 示例图： 元素显示和隐藏.mui-visibility 默认为设置元素可见，.mui-hidden 默认为设置元素隐藏。 注意：元素隐藏不占据位置。 转为行内或块级元素 设置成行内元素：给元素设置 .mui-inline 类 设置成块级元素：给元素设置 .mui-block 类 END…]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>mui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客的开始]]></title>
    <url>%2F2019%2F01%2F21%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%2F</url>
    <content type="text"><![CDATA[写博客其实，对于写作一事的深恶痛绝是打小就有的毛病。 在 IT 成长的路上，不可避免翻阅各种博客资料，逐渐发现写博客对于作者和读者来说都是有益的，深受启发。 故想通过写博客的形式分享自己的生活。 经历大学期间就读的是机械类专业，在毕业临近的压力下，思考后决定转战 IT 行业。 学习的主要渠道是通过观看视频教程，例如有慕课网，极客学院，腾讯课堂，菜鸟教程等公开的学习资料。 互联网作为伴着互联网的发展而成长的一份子。 互联网的普及，使人早早见识了各式各样的生活。 我周边有很多朋友们，都选择早早去一线城市发展。 日常上班上海被称之为魔都，这座城市是繁华的。 租了一间小房子，离公司不近。 工作日背着包在拥挤的地铁中起伏已是常态。 工作内容日常我的工作内容就是： 敲敲代码： 12345&lt;div&gt;bug&lt;/div&gt;&lt;p&gt;bug&lt;/p&gt;&lt;i&gt;bug&lt;/i&gt;&lt;b&gt;bug&lt;/b&gt;&lt;span&gt;bug&lt;/span&gt; 逛逛博客： 博客 之后会再多一项： 分享点文章放在个人博客里 计划19 年的目标： 学习一门后台语言。 存一半的工资。 看一本编程书籍。 END知之，行知，方得芝。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>分享</tag>
      </tags>
  </entry>
</search>
