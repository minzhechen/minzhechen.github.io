<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ES6中的Promise详解]]></title>
    <url>%2F2020%2F04%2F05%2FES6%E4%B8%ADPromise%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[ES6 中 Promise文章内容参考《ECMAScript 6 入门》。 什么是 Promise?Promise 是一种比传统的 回调函数和事件调用 更加合理的异步编程的一种解决方案。 Promise 对象可以获取异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作）的结果。 Promise 可解决的问题： 解决回调地狱的问题 支持多个并发的请求，获取并发请求返回的数据。 Promise 的缺点： 无法取消 Promise，一旦新建它就会立即执行，无法中途取消。 如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。 当处于 pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 回调地狱异步操作时，在请求成功的回调函数里继续写函数，或者继续进行异步操作，层层嵌套，就会形成回调地狱。 回调地狱会让我们的代码看起来很糟糕，难以维护，且性能低下。 Promise 的特点 Promise 有三种状态： pending（未完成） fulfilled（已成功） rejected（已失败） Promise 对象的状态改变，只有两种可能： 从 pending（未完成）变为 fulfilled（已成功） 从 pending（未完成）变为 rejected（已失败） 一旦状态改变，就不会再变，任何时候都可以得到这个结果 基本用法Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject。 Promise 实例生成以后，可以用 then 方法分别指定 resolved 状态和 rejected 状态的回调函数。 12345678910111213141516171819202122let promise = new Promise(function (resolve, reject) &#123; if (/* 异步操作成功 */) &#123; // resolve函数将 Promise对象的状态从“未完成”变为“成功” resolve(value); &#125; else &#123; // reject函数将 Promise对象的状态从“未完成”变为“失败” reject(error); &#125;&#125;);// then 方法有两个参数，第一个是成功 resolve 的回调，第二个是失败 reject 的回调promise.then( // Promise对象状态为“成功”时执行 function (value) &#123; &#125;, // Promise对象状态为“失败”时执行 function (error) &#123; &#125;) catch 方法相当于 then 方法的第二个参数，即失败 reject 的回调。 1234567promise .then( // Promise对象状态为“成功”时执行 function (value) &#123;&#125; ) .catch( // Promise对象状态为“失败”时执行 function (error) &#123;&#125; ) Promise 新建后就会立即执行。1234567891011121314151617181920console.log(1)let promise = new Promise(function (resolve, reject) &#123; console.log(2) resolve(3) console.log(4)&#125;)// then的第二个函数是可选的，非必须。promise.then(function (value) &#123; console.log(value)&#125;)console.log(5)// 1// 2// 4// 5// 3 上面代码中注意三点： Promise 新建后会立马执行其中代码 调用 resolve 或 reject 并不会终结 Promise 的参数函数的执行 在当前脚本所有同步任务执行完后才会执行 then 方法指定的回调函数 then() 的链式调用then 方法是定义在原型对象 Promise.prototype 上的。 调用 then 方法后返回的是一个新的 Promise 实例，因此可以继续调用 then 方法，实现链式调用。 12345678910111213new Promise((resolve, reject)=&gt; &#123; resolve(1)&#125;) .then(val =&gt; &#123; // 状态为成功时执行 console.log(val) return 2 &#125;) .then(value =&gt; &#123; // 状态为成功时执行 console.log(value) &#125;) // 1// 2 上面代码中，新建了一个 Promise 实例，实例内用 resolve 函数修改 Promise 对象状态从 “未完成” 变为 “成功” 并传递参数数字 1，第一个 then 方法的回调函数执行内容,完成后返回了数字 2 ,参数传递给了第二个 then 的回调函数。 在 then 方法中可以返回一个 Promise 对象（即有异步操作），这时后一个 then 方法的回调函数，会等待返回的 Promise 对象的状态发生变化，才会被调用。1234567891011121314151617181920function getNum (num) &#123; let promise = new Promise((resolve, reject)=&gt; &#123; setTimeout(() =&gt; &#123; resolve(num) &#125;, 1000) &#125;) return promise&#125;getNum(1) .then(val =&gt; &#123; console.log(val) return getNum(2) // 返回Promise对象 &#125;) .then(val =&gt; &#123; console.log(val) &#125;) // 1// 2 上面代码中，第一个 then 方法的回调函数执行完成后返回了一个 Promise 对象，一秒后，返回的 Promise 对象状态从 “未完成” 变为 “成功” ，此时开始执行第二个 then 方法里的回调函数。 catch() 方法详解跟 then 方法一样，catch 方法定义在原型对象 Promise.prototype 上的。 1234567891011121314let promise = new Promise((resolve, reject)=&gt; &#123; reject(&apos;出错啦&apos;)&#125;)promise .then(val =&gt; console.log(val)) .catch(err =&gt; console.log(err))// 等同于promise .then(val =&gt; console.log(val)) .then(null, err =&gt; console.log(err))// 出错啦// 出错啦 上面代码中，新建了一个 Promise 实例，实例内用 reject 函数,此时 Promise 对象状态从 “未完成” 变为 “失败” ,就调用 catch 方法指定的回调函数，处理这个错误。 接下来通过一个例子说明以下特性： 如果 Promise 状态已经变成resolved，再抛出错误是无效的。 then 方法指定的回调函数，如果运行中出错，也会被catch方法捕捉到。 Promise 对象抛出的错误，总是会被下一个catch语句捕获。 Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。1234567891011121314151617181920212223242526272829303132let promise = new Promise((resolve, reject)=&gt; &#123; // 解析一 resolve(&apos;Promise实例正确&apos;) throw new Error(&apos;Promise实例出错&apos;);&#125;)promise .then(val =&gt; &#123; // 解析二 console.log(val) throw new Error(&apos;then方法内出错&apos;) return &apos;链式调用then&apos; &#125;) .then(val =&gt; &#123; // 解析三 console.log(val) &#125;) .catch(err =&gt; &#123; // 解析四 console.log(err) throw new Error(&apos;catch方法内出错&apos;) &#125;) .catch(err =&gt; &#123; // 解析五 console.log(err) throw new Error(&apos;最后的catch方法出错&apos;) &#125;)setTimeout(() =&gt; &#123; // 解析六 console.log(&apos;promise后调用&apos;)&#125;, 0)// Promise实例正确// Error: then方法内出错// Error: catch方法内出错// Uncaught (in promise) Error: 最后的catch方法出错// promise后调用 根据上述代码块上注释的解析步骤，分析一下： 步骤一 构建了一个 Promise 对象，内部我们通过 resolve 函数修改状态为 “成功”。 创建了一个错误对象。 注意：Promise 对象状态已经变成 resolved，并不会二次修改状态，即第二步抛出的错误不会被捕捉。 步骤二 因为 Promise 对象状态为 “成功”，所以执行 then 方法第一个函数，打印了调用 resolve 函数传来的值。 创建了一个错误对象，修改 Promise 对象状态变为 “失败”。 返回字符串 ‘链式调用then’ 。 注意：(1) 此时状态已经变成 rejected。 (2) then 方法指定的回调函数抛出错误，也会被 catch 方法捕获。 步骤三 第一个 then 指定的回调函数抛出错误，即返回的 Promise 对象状态为 ‘失败’。 当前 then 不执行，直接执行下方最近的 catch 方法。 步骤四 捕捉到第一个 then 方法抛出的错误，打印错误内容。 创建了一个错误对象 步骤五 捕捉到第四步中 catch 方法内抛出的错误，打印错误内容。 创建了一个错误对象 因为之后没有 catch 方法了，于是浏览器打印了报错信息。 注意：Promise 对象内抛出的错误，不会退出进程、终止脚本执行。 步骤六 打印字符串 ‘promise后调用’。 finally() 方法finally 方法不管 Promise 对象状态是什么，都会执行。 123456789101112131415promise.finally(() =&gt; &#123; // 语句&#125;)// 等同于promise.then( result =&gt; &#123; // 语句 return result &#125;, error =&gt; &#123; // 语句 throw error &#125;) 上面代码中，如果不使用 finally 方法，同样的语句需要为成功和失败两种情况各写一次。有了 finally 方法，则只需要写一次。 finally 方法的回调函数不接受任何参数，且会返回原来的值。12345678910new Promise((resolve, reject) =&gt; &#123; resolve(1)&#125;) .finally(() =&gt; &#123; console.log(2) &#125;) .then(val =&gt; console.log(val))// 2// 1 从上面的实现还可以看到，finally 方法总是会返回原来的值。 finally 方法的实现也很简单。1234567Promise.prototype.finally = function (callback) &#123; let P = this.constructor; return this.then( value =&gt; P.resolve(callback()).then(() =&gt; value), reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;) );&#125;; all() 方法Promise.all() 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 Promise 的 all 方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。 12345678910111213141516171819202122232425262728293031323334353637function Apple () &#123; console.log(&apos;看到苹果&apos;) let promise = new Promise((resolve, reject) =&gt; &#123; // 做一些异步操作 setTimeout(function () &#123; console.log(&apos;买苹果&apos;) resolve(&apos;吃苹果&apos;) &#125;, 1000) &#125;) return promise&#125;function Peach () &#123; console.log(&apos;看到桃子&apos;) let promise = new Promise((resolve, reject) =&gt; &#123; // 做一些异步操作 setTimeout(function () &#123; console.log(&apos;买桃子&apos;) resolve(&apos;吃桃子&apos;) &#125;, 1000) &#125;) return promise&#125;let apple = Apple()let peach = Peach()let fruits = Promise.all([apple, peach])fruits.then(arr =&gt; &#123; console.log(arr)&#125;)// 看到苹果// 看到桃子// 买苹果// 买桃子// [&quot;吃苹果&quot;, &quot;吃桃子&quot;] 上面代码中，Promise.all() 方法接受一个数组作为参数，数组内每项都是 Promise 实例。fruits 的状态由 apple、peach 决定，分成两种情况。 （1）只有 apple、peach 的状态都变成 fulfilled，fruits 的状态才会变成 fulfilled，此时 apple、peach 的返回值组成一个数组，传递给 fruits 的回调函数。 （2）只要 apple、peach 之中有一个被rejected，fruits的状态就变成 rejected，此时第一个被 reject的实例的返回值，会传递给 fruits的回调函数。 下面是一个具体的例子。 123456789101112131415161718192021let promise1 = new Promise((resolve, reject) =&gt; &#123; resolve(1)&#125;)let promise2 = new Promise((resolve, reject) =&gt; &#123; throw new Error(&apos;出错了&apos;)&#125;)let promise3 = new Promise((resolve, reject) =&gt; &#123; reject(&apos;又出错了&apos;)&#125;)let p = Promise.all([promise1, promise2, promise3])p.then(val =&gt; &#123; console.log(val)&#125;).catch(err =&gt; &#123; console.log(&apos;捕捉到的出错：”&apos; + err + &apos;”&apos;)&#125;) // 捕捉到的出错：”Error: 出错了” 上面代码中，promise2 被 rejected, p 就变成 rejected，此时第一个被 reject 的实例的返回值，会传递给 p的回调函数。 注意，如果作为参数的 Promise 实例，自己定义了 catch方法，那么它一旦被rejected，并不会触发 Promise.all()的 catch 方法。 12345678910111213141516171819202122let promise1 = new Promise((resolve, reject) =&gt; &#123; resolve(1)&#125;).then(val =&gt; val)let promise2 = new Promise((resolve, reject) =&gt; &#123; throw new Error(&apos;出错了&apos;)&#125;).catch(err =&gt; err)let promise3 = new Promise((resolve, reject) =&gt; &#123; resolve(3)&#125;).then(val =&gt; console.log(val))let p = Promise.all([promise1, promise2, promise3])p.then(val =&gt; &#123; console.log(val)&#125;).catch(err =&gt; &#123; console.log(&apos;捕捉到的出错：”&apos; + err + &apos;”&apos;)&#125;)// 3// [1, Error: 出错了, undefined] 上面代码中，promise2 会 rejected,但是 promise2 有自己的 catch方法,该方法返回的是一个新的 Promise 实例，promise2 指向的实际上是这个实例。该实例执行完 catch 方法后，也会变成 resolved，导致 Promise.all()方法参数里面的两个实例都会变 resolved。 如果 promise2没有自己的 catch方法，就会调用 Promise.all() 的 catch方法。12345678910111213141516171819202122let promise1 = new Promise((resolve, reject) =&gt; &#123; resolve(1)&#125;).then(val =&gt; val)let promise2 = new Promise((resolve, reject) =&gt; &#123; throw new Error(&apos;出错了&apos;)&#125;)let promise3 = new Promise((resolve, reject) =&gt; &#123; resolve(3)&#125;).then(val =&gt; console.log(val))let p = Promise.all([promise1, promise2, promise3])p.then(val =&gt; &#123; console.log(val)&#125;).catch(err =&gt; &#123; console.log(&apos;捕捉到的出错：”&apos; + err + &apos;”&apos;)&#125;)// 3// 捕捉到的出错：”Error: 出错了” END无论怎样，都别丢了快乐和努力。 转载分享，请标明出处。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的this]]></title>
    <url>%2F2019%2F08%2F01%2FJavaScript%20%E4%B8%AD%E7%9A%84%20this%2F</url>
    <content type="text"><![CDATA[what’s this ？最近稍稍有点空闲，复习一下基础知识。说起 JavaScript 这门语言让人头疼的地方， 就绕不开 this 关键字的指向问题。 经过孜孜不倦地翻阅各大 IT 牛人的博客和相关网站之后……被虐的过程就不详细描述了！！ 总之，学习完之后，我就 “人不住手” 地总结了一下学到的知识，分享给大家。 学习 this 的必要众所周知，JavaScript 是一门基于原型的编程语言，我们可以通过使用关键词new 和 this 来实现代码的复用。 通过学习 this 等相关知识，能帮助你更好了解这门语言的设计模式和特性，加深你对代码的理解与使用。 this 是什么？this 指向谁？ this 是 JS 关键字，代表了一个空间地址。 this 是一个指针，指向函数运行时所在的环境。 通俗讲，就是谁调用了函数，函数内的 this 就指向谁。因此，我们想知道 this 指向谁，就一定要清楚到底是谁调用了函数。（PS：哈哈哈，说了句废话。） this 的四种调用默认调用独立函数调用时，this 指向 window 对象 123456789// 注意:这里不能使用letvar a = 1 // 全局用let声明的变量不属于windowfunction fn()&#123; console.log(this.a)&#125;// fn函数当前运行环境是 &quot;window&quot; 对象，所以this指向 全局window对象fn() // 1 严格模式下，默认绑定的 this 指向 undefined 。 1234;(function() &#123; &apos;use strict&apos; console.log(this) // undefined&#125;)() 对象调用如果函数执行时有上下文对象，会把函数里的 this 默认绑定到这个上下文对象上。 12345678910111213141516171819var a = 10function fn()&#123; console.log(this.a);&#125;let obj = &#123; a : 20, fn : fn&#125;// 对象obj调用了fn函数，fn的this指向当前的运行环境 &quot;obj&quot; 对象，输出20obj.fn() // 20// 因为 obj.fn 是引用类型，即 objFn === fn函数。let objFn = obj.fn// 独立调用函数 objFn，fn的this指向当前的运行环境 &quot;window&quot; 对象，输出10objFn() // 10 多层调用时，默认获取最后一层调用的上下文对象。 123456789101112131415161718var a = 10function fn() &#123; console.log(this.a)&#125;let obj = &#123; a: 20, fn: fn&#125;let obj2 = &#123; a: 30, obj: obj&#125;// 默认绑定最后调用的上下文，即this 指向 obj。obj2.obj.fn() // 20 call、apply、bind 强制绑定通过 call、apply、bind 改变函数的 this 指向。 绑定后无论怎么调用，也不会改变其 this 指向。 12345678910111213141516let obj = &#123; a: 10&#125;let obj2 = &#123; a: 20, fn() &#123; console.log(this.a) &#125;&#125;function fn2() &#123; obj2.fn.call(obj) // 把obj2.fn的this指向对象obj&#125;// 虽然执行环境是 &quot;window&quot;，但是因为通过call强制绑定了this，所以输出10fn2() // 10 new 绑定调用老生常谈，先看看 JS 中 new 关键字做了什么： 在内存中创建一个新对象 将新对象的proto指向构造函数的原型 prototype 对象 将构造函数的作用域赋值给新对象，（this 指向新对象） 执行构造函数中的代码（给这个新对象加属性和方法） 返回新对象，如果这个函数没有返回其他对象。 得出结论： 使用 new 调用函数，返回的对象的 this 始终指向自身。 12345678910111213141516function fn() &#123; this.a = 10 console.log(this)&#125;// obj 是从new出来的实例var obj = new fn() // fn &#123;a: 10&#125;// obj的this指向自身console.log(obj.a) // 10console.log(window.a) // undefined// &quot;window&quot;环境下执行了fn函数，this指向fnfn() // window对象console.log(window.a) // 10 箭头函数的 this箭头函数区别于以上介绍的运行规则，而是完全根据外部作用域来决定 this，但其父级是遵循 this 绑定规则的（即：如果箭头函数的父级的 this 指向 window，那么箭头函数的 this 也指向 window） 通过例子认识下： 1234567let obj=&#123; a:10, fn:function()&#123; setTimeout(function()&#123;console.log(this.a)&#125;) &#125;&#125;;obj.fn() // undefined 上述例子，可以发现在 setTimeout 中传入函数时，函数中的 this 会指向 window 对象，那么怎样让 this 指向 obj 对象? 修改下代码： 1234567let obj=&#123; a:10, fn:function()&#123; setTimeout(()=&gt;&#123;console.log(this.a)&#125;); &#125;&#125;;obj.fn() // 10 发现在我们使用箭头函数之后，使其继承了父函数 obj.fn 的 this 指针，达到了如下相同效果： 1234567let obj = &#123; a: 10, fn: function() &#123; console.log(this.a) &#125;&#125;obj.fn() // 10 看到这里，应该以及理解了箭头函数的 this 是继承来的意思。让我们再通过几个例子方便去理解箭头函数中的 this。 例 1： 12345678910let obj = &#123; fn: () =&gt; &#123; console.log(this) &#125;, fn2() &#123; console.log(this) &#125;&#125;obj.fn() // window对象obj.fn2() // &#123;fn: ƒ, fn2: ƒ&#125; 相信你一定很疑惑，为什么上述箭头函数里输出的是 window 对象，那么再看一段代码就清楚了。 例 2： 1234let obj = &#123; that: this&#125;console.log(obj.that) // window对象 我们发现，obj 里的 this 指向的是全局的 window 对象，那么就很好理解了，箭头函数继承了 obj 中的 this，也指向了全局 window 对象。 最后，我们可以通过箭头函数实现强制绑定 this 的效果。 没修改前的代码： 1234567891011121314var a = 10let obj = &#123; a : 20, fn() &#123; console.log(this.a); &#125;&#125;obj.fn() // 20let objFn = obj.fnobjFn() // 10 以上例子是我们讲解对象调用时的例子，我们不难发现，直接用 obj 对象去调用和独立调用时输出的结果不一致。如果你有仔细阅读文章的话，应该不难理解造成这种情形的原因。 接下来，我们通过箭头函数改造下代码，使我们复制的引用，独立调用时 this 也指向 obj。 修改后的代码： 12345678910111213141516171819var a = 10let obj = &#123; a: 20, fn() &#123; return () =&gt; &#123; console.log(this.a) &#125; &#125;&#125;obj.fn()() // 20let objFn = obj.fn()objFn() // 20// 发现即使是用call强制绑定，也无法改变其thisobjFn.call(window) // 20 END无论怎样，都别丢了快乐和努力。 转载分享，请标明出处。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识ES6中的Symbol]]></title>
    <url>%2F2019%2F07%2F16%2F%E5%88%9D%E8%AF%86ES6%E4%B8%AD%E7%9A%84Symbol%2F</url>
    <content type="text"><![CDATA[Symbol文章内容参考《ECMAScript 6 入门》。 概述Symbol 是 ES6 引入的一种新的原始数据类型，是独一无二的值。 注意： Symbol 函数不能使用 new 命令，因为生成的 Symbol 是一个原始类型的值，不是对象。 JavaScript 的七种数据类型： Undefined Null Boolean String Number Object Symbol 判断数据类型的方法123let data = Symbol()Object.prototype.toString.call(data).slice(8,-1) // &quot;Symbol&quot; 使用事项 Symbol 是独一无二的值。 1234567let idx = Symbol(&apos;pro&apos;)let key = Symbol(&apos;pro&apos;)idx // Symbol(pro)key // Symbol(pro)a === b // false Symbol 函数可以接受一个字符串作为参数（如：例 1），表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。 123456// 无法区分两者let s1 = Symbol()let s2 = Symbol()s1 // Symbol()s2 // Symbol() 当 Symbol 的参数是一个对象，就会调用该对象的 toString 方法（执行拆箱操作），将其转为字符串，然后才生成一个 Symbol 值。 1234567const obj = &#123; toString() &#123; return &apos;abc&apos; &#125;&#125;;const sym = Symbol(obj)sym // Symbol(abc) Symbol 值可以显式转为字符串和布尔值。但是不能转换成数值，也不能与其他类型的值进行运算，会报错。 转字符串 1234567let s = Symbol(&apos;Str Symbol&apos;)String(s) // &apos;Symbol(Str Symbol)&apos;s.toString() // &apos;Symbol(Str Symbol)&apos;// 不能将Symbol强制转换为字符串或是数字类型s + &apos;&apos; // TypeError: Cannot convert a Symbol value to a string 转布尔 123let s = Symbol(&apos;Str Symbol&apos;)Boolean(s) // true 转数值，运算 12345let s = Symbol(&apos;Str Symbol&apos;)Number(s) // Cannot convert a Symbol value to a number&apos;look at this&apos; + s // TypeError: Cannot convert a Symbol value to a string Symbol 函数不能使用 new 命令，因为生成的 Symbol 是一个原始类型的值，不是对象。 1new Symbol() // TypeError: Symbol is not a constructor Symbol.prototype.description创建 Symbol 的时候，可以添加一个描述。 1const s = Symbol(&apos;sym&apos;) 上面代码中，s 的描述就是字符串 sym。 但是，读取这个描述需要将 Symbol 显式转为字符串，即下面的写法。 123const s = Symbol(&apos;sym&apos;)String(s).slice(7,-1) // &quot;sym&quot; 上面的用法不是很方便。ES2019 提供了一个实例属性 description，直接返回 Symbol 的描述。 123const s = Symbol(&apos;sym&apos;)s.description // &quot;sym&quot; Symbol 作为对象属性名根据每一个 Symbol 值都是不等的特性，可以用 Symbol 作为唯一标识符，使用 Symbol 作为对象属性名可以保证不会出现同名的属性。 注意： symbol 不是字符串类型！！！使用 symbol 作为对象属性名时，必须放在方括号 [ ]之 中,因为点运算符后面总是字符串。 1234567891011121314151617let mySymbol = Symbol();// 第一种写法let a = &#123;&#125;;a[mySymbol] = &apos;Hello!&apos;;// 第二种写法let a = &#123; [mySymbol]: &apos;Hello!&apos;&#125;;// 第三种写法let a = &#123;&#125;;Object.defineProperty(a, mySymbol, &#123; value: &apos;Hello!&apos; &#125;);// 以上写法都得到同样结果a[mySymbol] // &quot;Hello!&quot; 使用 Symbol 来代替常量我们经常需要用一组常量区分不同的类型，处理不同的逻辑。其实我们并不在意这几个常量值是什么，只要是唯一的。这时可以用 Symbol 来实现。 123456789101112131415161718192021const apple = &apos;myApple&apos;const orange = &apos;myOrange&apos;const pear = &apos;myPear&apos;function getFruit(fruit) &#123; switch (fruit) &#123; case apple: console.log(&apos;我是a先生&apos;) break case orange: console.log(&apos;我是b女士&apos;) break case pear: console.log(&apos;我是c女士&apos;) break default: console.log(&apos;这是什么&apos;) &#125;&#125;getFruit(apple) // 我是a先生 观察以上代码，我们会发现，上述定义的常量值是什么并不重要。只要保证常量值间互不相等即可。 直接使用 Symbol 赋值即可： 123const apple = Symbol()const orange = Symbol()const pear = Symbol() Symbol 属性检索以 Symbol 作为属性名，不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。 Object.getOwnPropertySymbols 方法：获取指定对象的所有 Symbol 属性名的集合数组 123456789const a = Symbol(&apos;a&apos;)const b = Symbol(&apos;b&apos;)let obj = &#123; [a]: &apos;aaa&apos;, [b]: &apos;bbb&apos;&#125;console.log(Object.getOwnPropertySymbols(obj)) // [ Symbol(a), Symbol(b) ] Reflect.ownKeys 方法：返回所有类型的键名，包括常规键名和 Symbol 键名。 1234567let obj = &#123; [Symbol(&apos;a&apos;)]: &apos;aaa&apos;, b: &apos;bbb&apos;, c: &apos;ccc&apos;&#125;console.log(Reflect.ownKeys(obj)) // [ &apos;b&apos;, &apos;c&apos;, Symbol(a) ]st Symbol 定义类的私有属性/方法 (重点)以 Symbol 值作为名称的属性，不会被常规方法遍历得到。利用这个特性，可以为对象定义一些非私有的、但又希望只用于内部的方法。 123456789101112131415function myObject(name, age) &#123; let Age = Symbol() this.name = name this[Age] = age this.checkAge = (num) =&gt; &#123; return this[Age] === num &#125;&#125;let func = new myObject(&apos;z先生&apos;, 18)console.log(func.checkAge(18)) // trueconsole.log(func.name) // z先生console.log(func.age) // undefinedconsole.log(func[age]) // age is not defined Symbol 共享体系如果想创建一个可共享的 Symbol，可以使用 Symbol.for()方法。 Symbol.for 方法，接收一个字符串参数，然后全局环境中搜索有没有以该字符串参数作为名称的 Symbol 值： 如果有，就返回这个 Symbol 值 否则就全局环境中登记新建并返回一个以该字符串为名称的 Symbol 值。 123456789let s1 = Symbol.for(&apos;s&apos;)let s2 = Symbol(&apos;s&apos;)let s3 = Symbol.for(&apos;s&apos;)s1 === s2 // falses1 === s3 // trueSymbol(&apos;sym&apos;) === Symbol(&apos;sym&apos;) // falseSymbol.for(&apos;sym&apos;) === Symbol.for(&apos;sym&apos;) // true 注意： Symbol.for 为 Symbol 值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker 中取到同一个值。 12345iframe = document.createElement(&apos;iframe&apos;);iframe.src = String(window.location);document.body.appendChild(iframe);iframe.contentWindow.Symbol.for(&apos;foo&apos;) === Symbol.for(&apos;foo&apos;) // true 上面代码中，iframe 窗口生成的 Symbol 值，可以在主页面得到。 END无论怎样，都别丢了快乐和努力。 转载分享，请标明出处。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB常用语法]]></title>
    <url>%2F2019%2F04%2F28%2FMongoDB%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.基本指令 db ———— 查看当前正在使用的数据库 db.stats() ———— 查看当前数据库状态 show dbs ———— 显示所有数据库 如果数据为空，不会显示 use &lt;数据库名&gt; ———— 进入指定数据库 show collections ———— 显示当前数据库的集合 db.&lt;集合名&gt;.drop() ———— 删除指定集合 db.dropDatabase() ———— 删除当前数据库 2.MongoDB 的增删改查1234567$gte：大于等于$lte：小于等于$gt：大于$lt：小于 2.1 查看语法：db.&lt;集合名&gt;.find({}) 例子： 1234567// 指定条件查询：// 查询letao集合里name值为jack的数据db.collection.find(&#123;name: &apos;jack&apos;&#125;)// 查询letao集合里age值大于18的数据db.collection.find(&#123;age:&#123;$gt:18&#125;&#125;) 2.1.1 查询数据数量12// 后面加上 .count()db.collection.find(&#123;&#125;).count(); 2.1.2 数据排序12// col 集合中的数据按字段 likes 的降序排列 (1是正序，-1是倒序)db.collection.find(&#123;&#125;).sort(&#123;&quot;likes&quot;:-1&#125;) 2.1.3 模糊查询1234567891011121314// sql语法:select * from user where name like &quot;%花%&quot;;// MongoDB语法:db.collection.find(&#123;name:/花/&#125;);// 例子：查看students里的name包含 ”测试“ 的数据。db.collection.find(&#123;students.name:/测试/&#125;)// 若是以测试为开头的：db.collection.find(&#123;students.name:/^测试/&#125;)// 若是以测试为结尾的：db.collection.find(&#123;students.name:/测试$/&#125;) 2.1.4 查询表里 存在 指定字段(即值不为 null) 的数据12// 查询有age属性的数据（true是有，false没有）db.collection.find(&#123;age:&#123;$exists:true&#125;&#125;) 2.1.5 查询多个条件 返回符合其中一项 的数据12// 查找name值为zs 或 ls的数据db.collection.find(&#123;$or:[&#123;name:&apos;zs&apos;&#125;,&#123;name:&apos;ls&apos;&#125;]&#125;) 2.1.6 and 和 or 联合使用12// 查询age值为18，name值为张三或者李四的数据（注意是一个对象）db.collection.find(&#123; age:18 , $or: [ &#123;name:&apos;张三&apos;&#125;,&#123;name:&apos;李四&apos;&#125; ] &#125;) 2.1.7 查询 返回指定数量的数据指定数量：limit(数量) 跳过行数：skip(跳过数量) 12345// 找到的数据返回前5条db.collection.find().limit(5)// 找到的数据返回 跳过3条后的2条（即第4、5条）db.collection.find().limit(2).skip(3) 2.1.8 查询一个字段 多个条件 返回 符合其中之一的数据123&lt;!--需求：letao集合里age为 3 或 5 或 8 的数据--&gt;db.collection.find(&#123;age:&#123;$in:[3,5,8]&#125;&#125;)&lt;!--这里使用的是$in--&gt; 2.1.9 查询指定字段 指定类型的数据12345// 查询name类型为double类型的数据db.collection.find( &#123;name: &#123;$type:&apos;double&apos;&#125; &#125; )// 查询name类型为string类型的数据db.collection.find( &#123;name: &#123;$type:&apos;string&apos;&#125; &#125; ) 2.1.10 数组查询1234&lt;!--实例，一节课的老师的id可能有多个，这样：--&gt;&lt;!--&quot;teachers&quot; : [ 391, 659, 1534 ]--&gt;&lt;!--需求：查询包含老师id为1534的所有的数据--&gt;db.collection.find(&#123;teachers:1534&#125;) 2.1.11 查询数据 返回时 显示指定字段1234&lt;!--classes表集合中只显示id和title两个字段--&gt;&lt;!--下面的 status:&quot;700&quot; 为查询条件--&gt;&lt;!--查询出classes即合理status值为700的数据，只显示id和title--&gt;db.collection.find(&#123;status:&quot;700&quot;&#125;,&#123;_id:1,title:1&#125;) 2.2 插入语法：db.&lt;集合名&gt;.insert({}) 例子： 12345// 插入一条db.users.insert(&#123;name: &apos;jack&apos;, age: 18, gender: &apos;male&apos;&#125;)// 插入多条db.users.insertMany( [ &#123;name: &apos;tom&apos;, age: 19&#125;, &#123;name: &apos;jerry&apos;, age: 20&#125; ] ) 2.3 修改语法：db.&lt;集合名&gt;.update({}) 例子： 12345// 修改一条 name属性值为jack的数据，将其age改为20db.users.updateOne(&#123;name: &apos;jack&apos;&#125;, &#123;$set: &#123;age: 20&#125;&#125;)// 修改所有 age大于19的数据，将name设置为 中年人db.users.updateMany(&#123;age: &#123;$gt: 19&#125;&#125;,&#123;$set: &#123;name: &apos;中年人&apos;&#125;&#125;) 2.3.1 删除数据指定字段（不是删数据行） $exists：为 true 代表有这个字段名存在的项$unset: 替换成 null，\$unset 替换指定的元素为 null 而不是删除掉指定的元素，此行为保持数组大小和位置一致 123456789101112131415161718192021&lt;!--参数multi设置为true表示对集合中的所有匹配项执行该命令，若设置为false则只修改找到的第一条文档。--&gt;&lt;!--寻找到letao集合中有age这个属性的所有项，修改它们的name值为null --&gt;&lt;!--注意： 不管你值设为啥，$unset都把你选择字段删除--&gt;db.letao.update(&#123;&apos;age&apos;:&#123;$exists:true&#125;&#125;, &#123;$unset:&#123;name:&apos;zs&apos;&#125;&#125;, &#123;multi:true&#125;)db.letao.update(&#123;&apos;age&apos;:&#123;$exists:true&#125;&#125;, &#123;$unset:&#123;name:&apos;&apos;&#125;&#125;, false,true) // 第一个Boolean代表如果没有找到数据，是否插入一条第二个Boolean代表是否匹配所有找到数据&lt;!--如果指定的字段不存在则操作不做任何处理；--&gt;&lt;!--当使用$操作符匹配任何数组元素，$unset替换指定的元素为null而不是删除掉指定的元素，此行为保持数组大小和位置一致；--&gt;&lt;!--如下update()操作删除掉符合条件sku为unknown的文档字段quantity和instock--&gt;db.products.update( &#123; sku: &quot;unknown&quot; &#125;, &#123; $unset: &#123; quantity: &quot;&quot;, instock: &quot;&quot; &#125; &#125;) 2.4 删除语法：db.&lt;集合名&gt;.delete({}) 例子： 12345// 删除一条 age 为18的数据：db.users.deleteOne(&#123;age: 18&#125;)// 删除所有name为jack的数据db.users.deleteMany(&#123; name: &apos;jack&apos; &#125;) 3.设置使用索引（重要）作用：给字段设置索引可以加快查询此字段的速度 语法： 设置值为 1 就代表按照升序进行索引，-1 代表按照降序进行索引。 查看索引状态：db.表名.getIndexed()设置索引：db.表名.createIndex()删除索引：db.表名.dropIndex() 1234567891011// 查看当前letao表所有索引的状态db.letao.getIndexes()// 给title字段设置升序的索引，因为设置了unique为true，表示title值不能重复db.letao.createIndex(&#123;title:1&#125;,&#123;unique:true&#125;)// 设置title字段为升序，age字段为降序的组合索引db.letao.createIndex(&#123;title:1&#125;,&#123;age:-1&#125;)// 删除title字段为升序的索引db.letao.dropIndex(&#123;title:1&#125;) END…]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mui组件通用css类]]></title>
    <url>%2F2019%2F01%2F23%2Fmui%E7%BB%84%E4%BB%B6%E9%80%9A%E7%94%A8css%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[mui 通用类最近要用 mui 框架写一个项目。 于是根据官网资料和查阅资料整理了一下 mui 常用的 css 类。 注意： 一切内容都要包裹在 .mui-content 中，否则就有可能被固定栏遮罩，除了固定栏之外。 固定栏是指带有 .mui-bar 属性的节点，他们都是基于 fixed 定位的，使用时需遵循一个规则：放在.mui-content 元素之前。 即使是底部工具条和底部选项卡，也要放在 .mui-content 之前，否则固定栏会遮住部分主内容。 颜色（color） danger 红色(red) warning 黄色(yellow) primary 蓝色(blue) success 绿色(green) royal 紫色(purple) 注意：.mui-btn-primary 等效于.mui-btn-blue; 背景颜色可以给任意元素添加 .mui-bg-*类添加背景颜色，可选参数为 primary/positive/negative。 123&lt;div class=&quot;mui-bg-negative&quot;&gt;红色背景&lt;/div&gt;&lt;div class=&quot;mui-bg-primary&quot;&gt;蓝色背景&lt;/div&gt;&lt;div class=&quot;mui-bg-positive&quot;&gt;绿色背景&lt;/div&gt; 示例图： badge（数字角标）角标的核心类是 .mui-badge，默认为实心灰色背景；同时，mui 还内置了蓝色（blue）、绿色(green)、黄色(yellow)、红色(red)、紫色(purple)五种色系的数字角标，如下： 123456&lt;span class=&quot;mui-badge&quot;&gt;默认灰色&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-primary&quot;&gt;蓝色&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-success&quot;&gt;绿色&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-warning&quot;&gt;黄色&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-danger&quot;&gt;红色&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-purple&quot;&gt;紫色&lt;/span&gt; 示例图：如果不要底色，则增加 .mui-badge-inverted 类即可，如下： 123456&lt;span class=&quot;mui-badge mui-badge-inverted&quot;&gt;默认灰色&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-primary mui-badge-inverted&quot;&gt;蓝色&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-success mui-badge-inverted&quot;&gt;绿色&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-warning mui-badge-inverted&quot;&gt;黄色&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-danger mui-badge-inverted&quot;&gt;红色&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-purple mui-badge-inverted&quot;&gt;紫色&lt;/span&gt; 示例图： 按钮在 button 节点上增加.mui-btn 类，即可生成默认按钮；若需要其他颜色的按钮，则继续增加对应 class 即可。默认按钮有底色，运行效果如下： 123456&lt;button type=&quot;button&quot; class=&quot;mui-btn&quot;&gt;默认&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-primary&quot;&gt;蓝色&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-success&quot;&gt;绿色&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-warning&quot;&gt;黄色&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-danger&quot;&gt;红色&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-royal&quot;&gt;紫色&lt;/button&gt; 示例图： 若希望无底色、有边框的按钮，仅需增加 .mui-btn-outlined 类即可，代码如下： 123456&lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-outlined&quot;&gt;默认&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-primary mui-btn-outlined&quot;&gt;蓝色&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-success mui-btn-outlined&quot;&gt;绿色&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-warning mui-btn-outlined&quot;&gt;黄色&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-danger mui-btn-outlined&quot;&gt;红色&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-royal mui-btn-outlined&quot;&gt;紫色&lt;/button&gt; 示例图： 字体样式文字对齐通过 .mui-text-*来控制文字对齐方式,代码如下： 123&lt;div class=&quot;mui-text-left mui-bg-negative&quot;&gt;居左&lt;/div&gt;&lt;div class=&quot;mui-text-center mui-bg-primary&quot;&gt;居中&lt;/div&gt;&lt;div class=&quot;mui-text-right mui-bg-positive&quot;&gt;居右&lt;/div&gt; 示例图： 文字溢出省略.mui-ellipsis 来控制文字溢出省略需要设置显示多行，通过设置-webkit-line-clamp 属性，如显示三行添加 style=”-webkit-line-clamp:3”，代码如下： 123456789&lt;p class=&quot;mui-ellipsis&quot;&gt;超出一行的文字省略，超出一行的文字省略，超出一行的文字省略，超出一行的文字省略&lt;/p&gt;&lt;br/&gt;&lt;p class=&quot;mui-ellipsis-2&quot;&gt;超出两行的文字省略，超出两行的文字省略，超出两行的文字省略，超出两行的文字省略，超出两行的文字省略，超出两行的文字省略&lt;/p&gt;&lt;br/&gt;&lt;p class=&quot;mui-ellipsis-2&quot; style=&quot;-webkit-line-clamp:3&quot;&gt;超出三行的文字省略，超出三行的文字省略，超出三行的文字省略，超出三行的文字省略，超出三行的文字省略，超出三行的文字省略，超出三行的文字省略，超出三行的文字省略超出三行的文字省略，&lt;/p&gt; 示例图： 浮动给元素设置.mui-pull-left 或者.mui-pull-right 类，设置浮动。使用.mui-clearfix 清除浮动。 1234&lt;div class=&quot;mui-clearfix&quot;&gt; &lt;div class=&quot;mui-pull-left mui-bg-negative&quot;&gt;我在左边&lt;/div&gt; &lt;div class=&quot;mui-pull-right mui-bg-primary&quot;&gt;我在右边&lt;/div&gt;&lt;/div&gt; 示例图： 元素显示和隐藏.mui-visibility 默认为设置元素可见，.mui-hidden 默认为设置元素隐藏。 注意：元素隐藏不占据位置。 转为行内或块级元素 设置成行内元素：给元素设置 .mui-inline 类 设置成块级元素：给元素设置 .mui-block 类 END…]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>mui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客的开始]]></title>
    <url>%2F2019%2F01%2F21%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%2F</url>
    <content type="text"><![CDATA[写博客其实，对于写作一事的深恶痛绝是打小就有的毛病。 在 IT 成长的路上，不可避免翻阅各种博客资料，逐渐发现写博客对于作者和读者来说都是有益的，深受启发。 故想通过写博客的形式分享自己的生活。 经历大学期间就读的是机械类专业，在毕业临近的压力下，思考后决定转战 IT 行业。 学习的主要渠道是通过观看视频教程，例如有慕课网，极客学院，腾讯课堂，菜鸟教程等公开的学习资料。 互联网作为伴着互联网的发展而成长的一份子。 互联网的普及，使人早早见识了各式各样的生活。 我周边有很多朋友们，都选择早早去一线城市发展。 日常上班上海被称之为魔都，这座城市是繁华的。 租了一间小房子，离公司不近。 工作日背着包在拥挤的地铁中起伏已是常态。 工作内容日常我的工作内容就是： 敲敲代码： 12345&lt;div&gt;bug&lt;/div&gt;&lt;p&gt;bug&lt;/p&gt;&lt;i&gt;bug&lt;/i&gt;&lt;b&gt;bug&lt;/b&gt;&lt;span&gt;bug&lt;/span&gt; 逛逛博客： 博客 之后会再多一项： 分享点文章放在个人博客里 计划19 年的目标： 学习一门后台语言。 存一半的工资。 看一本编程书籍。 END无论怎样，都别丢了快乐和努力。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>分享</tag>
      </tags>
  </entry>
</search>
